/* Code generated by codegen/main.go. DO NOT EDIT. */

use std::collections::HashMap;

use nanoserde::{DeJson, SerJson};

#[derive(Debug, Clone)]
pub enum Authentication {
    Basic { username: String, password: String },
    Bearer { token: String },
}

#[derive(Debug, Clone, PartialEq, Copy)]
pub enum Method {
    Post,
    Get,
    Put,
    Delete,
}

#[derive(Debug, Clone)]
pub struct RestRequest<Response> {
    pub authentication: Authentication,
    pub urlpath: String,
    pub query_params: String,
    pub body: String,
    pub method: Method,
    _marker: std::marker::PhantomData<Response>,
}

trait ToRestString {
    fn to_string(&self) -> String;
}

/// A single user-role pair.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct GroupUserListGroupUser {
    pub state: i32,
    pub user: ApiUser,
}

impl ToRestString for GroupUserListGroupUser {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"state\": {}", self.state.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"user\": {}", self.user.to_string()));
        output.push_str("}");
        return output;
    }
}

/// A single group-role pair.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct UserGroupListUserGroup {
    pub group: ApiGroup,
    pub state: i32,
}

impl ToRestString for UserGroupListUserGroup {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"group\": {}", self.group.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"state\": {}", self.state.to_string()));
        output.push_str("}");
        return output;
    }
}

/// - UNKNOWN: Unknown environment.  - SANDBOX: Sandbox/test environment.  - PRODUCTION: Production environment.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ValidatedPurchaseEnvironment {}

impl ToRestString for ValidatedPurchaseEnvironment {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");
        output.push_str("}");
        return output;
    }
}

/// - APPLE_APP_STORE: Apple App Store  - GOOGLE_PLAY_STORE: Google Play Store  - HUAWEI_APP_GALLERY: Huawei App Gallery
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ValidatedPurchaseStore {}

impl ToRestString for ValidatedPurchaseStore {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");
        output.push_str("}");
        return output;
    }
}

/// Record values to write.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct WriteLeaderboardRecordRequestLeaderboardRecordWrite {
    pub metadata: String,
    pub operator: ApiOverrideOperator,
    pub score: String,
    pub subscore: String,
}

impl ToRestString for WriteLeaderboardRecordRequestLeaderboardRecordWrite {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"metadata\": \"{}\"", self.metadata));

        output.push_str(",");
        output.push_str(&format!("\"operator\": {}", self.operator.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"score\": \"{}\"", self.score));

        output.push_str(",");
        output.push_str(&format!("\"subscore\": \"{}\"", self.subscore));
        output.push_str("}");
        return output;
    }
}

/// Record values to write.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct WriteTournamentRecordRequestTournamentRecordWrite {
    pub metadata: String,
    pub operator: ApiOverrideOperator,
    pub score: String,
    pub subscore: String,
}

impl ToRestString for WriteTournamentRecordRequestTournamentRecordWrite {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"metadata\": \"{}\"", self.metadata));

        output.push_str(",");
        output.push_str(&format!("\"operator\": {}", self.operator.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"score\": \"{}\"", self.score));

        output.push_str(",");
        output.push_str(&format!("\"subscore\": \"{}\"", self.subscore));
        output.push_str("}");
        return output;
    }
}

/// A user with additional account details. Always the current user.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiAccount {
    pub custom_id: String,
    pub devices: Vec<ApiAccountDevice>,
    pub disable_time: String,
    pub email: String,
    pub user: ApiUser,
    pub verify_time: String,
    pub wallet: String,
}

impl ToRestString for ApiAccount {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"customId\": \"{}\"", self.custom_id));

        output.push_str(",");
        output.push_str(&format!("\"devices\": [{}]", {
            let vec_string = self
                .devices
                .iter()
                .map(|x| x.to_string())
                .collect::<Vec<_>>();
            vec_string.join(", ")
        }));

        output.push_str(",");
        output.push_str(&format!("\"disableTime\": \"{}\"", self.disable_time));

        output.push_str(",");
        output.push_str(&format!("\"email\": \"{}\"", self.email));

        output.push_str(",");
        output.push_str(&format!("\"user\": {}", self.user.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"verifyTime\": \"{}\"", self.verify_time));

        output.push_str(",");
        output.push_str(&format!("\"wallet\": \"{}\"", self.wallet));
        output.push_str("}");
        return output;
    }
}

/// Send a Apple Sign In token to the server. Used with authenticate/link/unlink.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiAccountApple {
    pub token: String,
    pub vars: HashMap<String, String>,
}

impl ToRestString for ApiAccountApple {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"token\": \"{}\"", self.token));

        output.push_str(",");
        output.push_str(&format!("\"vars\": {{ {} }}", {
            let map_string = self
                .vars
                .iter()
                .map(|(key, value)| format!("\"{}\": \"{}\"", key.to_string(), value.to_string()))
                .collect::<Vec<_>>();
            map_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// Send a custom ID to the server. Used with authenticate/link/unlink.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiAccountCustom {
    pub id: String,
    pub vars: HashMap<String, String>,
}

impl ToRestString for ApiAccountCustom {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"id\": \"{}\"", self.id));

        output.push_str(",");
        output.push_str(&format!("\"vars\": {{ {} }}", {
            let map_string = self
                .vars
                .iter()
                .map(|(key, value)| format!("\"{}\": \"{}\"", key.to_string(), value.to_string()))
                .collect::<Vec<_>>();
            map_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// Send a device to the server. Used with authenticate/link/unlink and user.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiAccountDevice {
    pub id: String,
    pub vars: HashMap<String, String>,
}

impl ToRestString for ApiAccountDevice {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"id\": \"{}\"", self.id));

        output.push_str(",");
        output.push_str(&format!("\"vars\": {{ {} }}", {
            let map_string = self
                .vars
                .iter()
                .map(|(key, value)| format!("\"{}\": \"{}\"", key.to_string(), value.to_string()))
                .collect::<Vec<_>>();
            map_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// Send an email with password to the server. Used with authenticate/link/unlink.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiAccountEmail {
    pub email: String,
    pub password: String,
    pub vars: HashMap<String, String>,
}

impl ToRestString for ApiAccountEmail {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"email\": \"{}\"", self.email));

        output.push_str(",");
        output.push_str(&format!("\"password\": \"{}\"", self.password));

        output.push_str(",");
        output.push_str(&format!("\"vars\": {{ {} }}", {
            let map_string = self
                .vars
                .iter()
                .map(|(key, value)| format!("\"{}\": \"{}\"", key.to_string(), value.to_string()))
                .collect::<Vec<_>>();
            map_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// Send a Facebook token to the server. Used with authenticate/link/unlink.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiAccountFacebook {
    pub token: String,
    pub vars: HashMap<String, String>,
}

impl ToRestString for ApiAccountFacebook {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"token\": \"{}\"", self.token));

        output.push_str(",");
        output.push_str(&format!("\"vars\": {{ {} }}", {
            let map_string = self
                .vars
                .iter()
                .map(|(key, value)| format!("\"{}\": \"{}\"", key.to_string(), value.to_string()))
                .collect::<Vec<_>>();
            map_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// Send a Facebook Instant Game token to the server. Used with authenticate/link/unlink.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiAccountFacebookInstantGame {
    pub signed_player_info: String,
    pub vars: HashMap<String, String>,
}

impl ToRestString for ApiAccountFacebookInstantGame {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!(
            "\"signedPlayerInfo\": \"{}\"",
            self.signed_player_info
        ));

        output.push_str(",");
        output.push_str(&format!("\"vars\": {{ {} }}", {
            let map_string = self
                .vars
                .iter()
                .map(|(key, value)| format!("\"{}\": \"{}\"", key.to_string(), value.to_string()))
                .collect::<Vec<_>>();
            map_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// Send Apple's Game Center account credentials to the server. Used with authenticate/link/unlink.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiAccountGameCenter {
    pub bundle_id: String,
    pub player_id: String,
    pub public_key_url: String,
    pub salt: String,
    pub signature: String,
    pub timestamp_seconds: String,
    pub vars: HashMap<String, String>,
}

impl ToRestString for ApiAccountGameCenter {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"bundleId\": \"{}\"", self.bundle_id));

        output.push_str(",");
        output.push_str(&format!("\"playerId\": \"{}\"", self.player_id));

        output.push_str(",");
        output.push_str(&format!("\"publicKeyUrl\": \"{}\"", self.public_key_url));

        output.push_str(",");
        output.push_str(&format!("\"salt\": \"{}\"", self.salt));

        output.push_str(",");
        output.push_str(&format!("\"signature\": \"{}\"", self.signature));

        output.push_str(",");
        output.push_str(&format!(
            "\"timestampSeconds\": \"{}\"",
            self.timestamp_seconds
        ));

        output.push_str(",");
        output.push_str(&format!("\"vars\": {{ {} }}", {
            let map_string = self
                .vars
                .iter()
                .map(|(key, value)| format!("\"{}\": \"{}\"", key.to_string(), value.to_string()))
                .collect::<Vec<_>>();
            map_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// Send a Google token to the server. Used with authenticate/link/unlink.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiAccountGoogle {
    pub token: String,
    pub vars: HashMap<String, String>,
}

impl ToRestString for ApiAccountGoogle {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"token\": \"{}\"", self.token));

        output.push_str(",");
        output.push_str(&format!("\"vars\": {{ {} }}", {
            let map_string = self
                .vars
                .iter()
                .map(|(key, value)| format!("\"{}\": \"{}\"", key.to_string(), value.to_string()))
                .collect::<Vec<_>>();
            map_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// Send a Steam token to the server. Used with authenticate/link/unlink.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiAccountSteam {
    pub token: String,
    pub vars: HashMap<String, String>,
}

impl ToRestString for ApiAccountSteam {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"token\": \"{}\"", self.token));

        output.push_str(",");
        output.push_str(&format!("\"vars\": {{ {} }}", {
            let map_string = self
                .vars
                .iter()
                .map(|(key, value)| format!("\"{}\": \"{}\"", key.to_string(), value.to_string()))
                .collect::<Vec<_>>();
            map_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// A message sent on a channel.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiChannelMessage {
    pub channel_id: String,
    pub code: i32,
    pub content: String,
    pub create_time: String,
    pub group_id: String,
    pub message_id: String,
    pub persistent: bool,
    pub room_name: String,
    pub sender_id: String,
    pub update_time: String,
    pub user_id_one: String,
    pub user_id_two: String,
    pub username: String,
}

impl ToRestString for ApiChannelMessage {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"channelId\": \"{}\"", self.channel_id));

        output.push_str(",");
        output.push_str(&format!("\"code\": {}", self.code.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"content\": \"{}\"", self.content));

        output.push_str(",");
        output.push_str(&format!("\"createTime\": \"{}\"", self.create_time));

        output.push_str(",");
        output.push_str(&format!("\"groupId\": \"{}\"", self.group_id));

        output.push_str(",");
        output.push_str(&format!("\"messageId\": \"{}\"", self.message_id));

        output.push_str(",");
        output.push_str(&format!("\"persistent\": {}", self.persistent.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"roomName\": \"{}\"", self.room_name));

        output.push_str(",");
        output.push_str(&format!("\"senderId\": \"{}\"", self.sender_id));

        output.push_str(",");
        output.push_str(&format!("\"updateTime\": \"{}\"", self.update_time));

        output.push_str(",");
        output.push_str(&format!("\"userIdOne\": \"{}\"", self.user_id_one));

        output.push_str(",");
        output.push_str(&format!("\"userIdTwo\": \"{}\"", self.user_id_two));

        output.push_str(",");
        output.push_str(&format!("\"username\": \"{}\"", self.username));
        output.push_str("}");
        return output;
    }
}

/// A list of channel messages, usually a result of a list operation.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiChannelMessageList {
    pub cacheable_cursor: String,
    pub messages: Vec<ApiChannelMessage>,
    pub next_cursor: String,
    pub prev_cursor: String,
}

impl ToRestString for ApiChannelMessageList {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!(
            "\"cacheableCursor\": \"{}\"",
            self.cacheable_cursor
        ));

        output.push_str(",");
        output.push_str(&format!("\"messages\": [{}]", {
            let vec_string = self
                .messages
                .iter()
                .map(|x| x.to_string())
                .collect::<Vec<_>>();
            vec_string.join(", ")
        }));

        output.push_str(",");
        output.push_str(&format!("\"nextCursor\": \"{}\"", self.next_cursor));

        output.push_str(",");
        output.push_str(&format!("\"prevCursor\": \"{}\"", self.prev_cursor));
        output.push_str("}");
        return output;
    }
}

/// Create a group with the current user as owner.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiCreateGroupRequest {
    pub avatar_url: String,
    pub description: String,
    pub lang_tag: String,
    pub max_count: i32,
    pub name: String,
    pub open: bool,
}

impl ToRestString for ApiCreateGroupRequest {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"avatarUrl\": \"{}\"", self.avatar_url));

        output.push_str(",");
        output.push_str(&format!("\"description\": \"{}\"", self.description));

        output.push_str(",");
        output.push_str(&format!("\"langTag\": \"{}\"", self.lang_tag));

        output.push_str(",");
        output.push_str(&format!("\"maxCount\": {}", self.max_count.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"name\": \"{}\"", self.name));

        output.push_str(",");
        output.push_str(&format!("\"open\": {}", self.open.to_string()));
        output.push_str("}");
        return output;
    }
}

/// Storage objects to delete.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiDeleteStorageObjectId {
    pub collection: String,
    pub key: String,
    pub version: String,
}

impl ToRestString for ApiDeleteStorageObjectId {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"collection\": \"{}\"", self.collection));

        output.push_str(",");
        output.push_str(&format!("\"key\": \"{}\"", self.key));

        output.push_str(",");
        output.push_str(&format!("\"version\": \"{}\"", self.version));
        output.push_str("}");
        return output;
    }
}

/// Batch delete storage objects.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiDeleteStorageObjectsRequest {
    pub object_ids: Vec<ApiDeleteStorageObjectId>,
}

impl ToRestString for ApiDeleteStorageObjectsRequest {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"objectIds\": [{}]", {
            let vec_string = self
                .object_ids
                .iter()
                .map(|x| x.to_string())
                .collect::<Vec<_>>();
            vec_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// Represents an event to be passed through the server to registered event handlers.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiEvent {
    pub external: bool,
    pub name: String,
    pub properties: HashMap<String, String>,
    pub timestamp: String,
}

impl ToRestString for ApiEvent {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"external\": {}", self.external.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"name\": \"{}\"", self.name));

        output.push_str(",");
        output.push_str(&format!("\"properties\": {{ {} }}", {
            let map_string = self
                .properties
                .iter()
                .map(|(key, value)| format!("\"{}\": \"{}\"", key.to_string(), value.to_string()))
                .collect::<Vec<_>>();
            map_string.join(", ")
        }));

        output.push_str(",");
        output.push_str(&format!("\"timestamp\": \"{}\"", self.timestamp));
        output.push_str("}");
        return output;
    }
}

/// A friend of a user.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiFriend {
    pub state: i32,
    pub update_time: String,
    pub user: ApiUser,
}

impl ToRestString for ApiFriend {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"state\": {}", self.state.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"updateTime\": \"{}\"", self.update_time));

        output.push_str(",");
        output.push_str(&format!("\"user\": {}", self.user.to_string()));
        output.push_str("}");
        return output;
    }
}

/// A collection of zero or more friends of the user.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiFriendList {
    pub cursor: String,
    pub friends: Vec<ApiFriend>,
}

impl ToRestString for ApiFriendList {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"cursor\": \"{}\"", self.cursor));

        output.push_str(",");
        output.push_str(&format!("\"friends\": [{}]", {
            let vec_string = self
                .friends
                .iter()
                .map(|x| x.to_string())
                .collect::<Vec<_>>();
            vec_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// A group in the server.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiGroup {
    pub avatar_url: String,
    pub create_time: String,
    pub creator_id: String,
    pub description: String,
    pub edge_count: i32,
    pub id: String,
    pub lang_tag: String,
    pub max_count: i32,
    pub metadata: String,
    pub name: String,
    pub open: bool,
    pub update_time: String,
}

impl ToRestString for ApiGroup {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"avatarUrl\": \"{}\"", self.avatar_url));

        output.push_str(",");
        output.push_str(&format!("\"createTime\": \"{}\"", self.create_time));

        output.push_str(",");
        output.push_str(&format!("\"creatorId\": \"{}\"", self.creator_id));

        output.push_str(",");
        output.push_str(&format!("\"description\": \"{}\"", self.description));

        output.push_str(",");
        output.push_str(&format!("\"edgeCount\": {}", self.edge_count.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"id\": \"{}\"", self.id));

        output.push_str(",");
        output.push_str(&format!("\"langTag\": \"{}\"", self.lang_tag));

        output.push_str(",");
        output.push_str(&format!("\"maxCount\": {}", self.max_count.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"metadata\": \"{}\"", self.metadata));

        output.push_str(",");
        output.push_str(&format!("\"name\": \"{}\"", self.name));

        output.push_str(",");
        output.push_str(&format!("\"open\": {}", self.open.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"updateTime\": \"{}\"", self.update_time));
        output.push_str("}");
        return output;
    }
}

/// One or more groups returned from a listing operation.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiGroupList {
    pub cursor: String,
    pub groups: Vec<ApiGroup>,
}

impl ToRestString for ApiGroupList {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"cursor\": \"{}\"", self.cursor));

        output.push_str(",");
        output.push_str(&format!("\"groups\": [{}]", {
            let vec_string = self
                .groups
                .iter()
                .map(|x| x.to_string())
                .collect::<Vec<_>>();
            vec_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// A list of users belonging to a group, along with their role.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiGroupUserList {
    pub cursor: String,
    pub group_users: Vec<GroupUserListGroupUser>,
}

impl ToRestString for ApiGroupUserList {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"cursor\": \"{}\"", self.cursor));

        output.push_str(",");
        output.push_str(&format!("\"groupUsers\": [{}]", {
            let vec_string = self
                .group_users
                .iter()
                .map(|x| x.to_string())
                .collect::<Vec<_>>();
            vec_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// Represents a complete leaderboard record with all scores and associated metadata.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiLeaderboardRecord {
    pub create_time: String,
    pub expiry_time: String,
    pub leaderboard_id: String,
    pub max_num_score: i32,
    pub metadata: String,
    pub num_score: i32,
    pub owner_id: String,
    pub rank: String,
    pub score: String,
    pub subscore: String,
    pub update_time: String,
    pub username: String,
}

impl ToRestString for ApiLeaderboardRecord {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"createTime\": \"{}\"", self.create_time));

        output.push_str(",");
        output.push_str(&format!("\"expiryTime\": \"{}\"", self.expiry_time));

        output.push_str(",");
        output.push_str(&format!("\"leaderboardId\": \"{}\"", self.leaderboard_id));

        output.push_str(",");
        output.push_str(&format!(
            "\"maxNumScore\": {}",
            self.max_num_score.to_string()
        ));

        output.push_str(",");
        output.push_str(&format!("\"metadata\": \"{}\"", self.metadata));

        output.push_str(",");
        output.push_str(&format!("\"numScore\": {}", self.num_score.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"ownerId\": \"{}\"", self.owner_id));

        output.push_str(",");
        output.push_str(&format!("\"rank\": \"{}\"", self.rank));

        output.push_str(",");
        output.push_str(&format!("\"score\": \"{}\"", self.score));

        output.push_str(",");
        output.push_str(&format!("\"subscore\": \"{}\"", self.subscore));

        output.push_str(",");
        output.push_str(&format!("\"updateTime\": \"{}\"", self.update_time));

        output.push_str(",");
        output.push_str(&format!("\"username\": \"{}\"", self.username));
        output.push_str("}");
        return output;
    }
}

/// A set of leaderboard records, may be part of a leaderboard records page or a batch of individual records.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiLeaderboardRecordList {
    pub next_cursor: String,
    pub owner_records: Vec<ApiLeaderboardRecord>,
    pub prev_cursor: String,
    pub records: Vec<ApiLeaderboardRecord>,
}

impl ToRestString for ApiLeaderboardRecordList {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"nextCursor\": \"{}\"", self.next_cursor));

        output.push_str(",");
        output.push_str(&format!("\"ownerRecords\": [{}]", {
            let vec_string = self
                .owner_records
                .iter()
                .map(|x| x.to_string())
                .collect::<Vec<_>>();
            vec_string.join(", ")
        }));

        output.push_str(",");
        output.push_str(&format!("\"prevCursor\": \"{}\"", self.prev_cursor));

        output.push_str(",");
        output.push_str(&format!("\"records\": [{}]", {
            let vec_string = self
                .records
                .iter()
                .map(|x| x.to_string())
                .collect::<Vec<_>>();
            vec_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// Link Steam to the current user's account.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiLinkSteamRequest {
    pub account: ApiAccountSteam,
    pub sync: bool,
}

impl ToRestString for ApiLinkSteamRequest {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"account\": {}", self.account.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"sync\": {}", self.sync.to_string()));
        output.push_str("}");
        return output;
    }
}

/// Represents a realtime match.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiMatch {
    pub authoritative: bool,
    pub handler_name: String,
    pub label: String,
    pub match_id: String,
    pub size: i32,
    pub tick_rate: i32,
}

impl ToRestString for ApiMatch {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!(
            "\"authoritative\": {}",
            self.authoritative.to_string()
        ));

        output.push_str(",");
        output.push_str(&format!("\"handlerName\": \"{}\"", self.handler_name));

        output.push_str(",");
        output.push_str(&format!("\"label\": \"{}\"", self.label));

        output.push_str(",");
        output.push_str(&format!("\"matchId\": \"{}\"", self.match_id));

        output.push_str(",");
        output.push_str(&format!("\"size\": {}", self.size.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"tickRate\": {}", self.tick_rate.to_string()));
        output.push_str("}");
        return output;
    }
}

/// A list of realtime matches.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiMatchList {
    pub matches: Vec<ApiMatch>,
}

impl ToRestString for ApiMatchList {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"matches\": [{}]", {
            let vec_string = self
                .matches
                .iter()
                .map(|x| x.to_string())
                .collect::<Vec<_>>();
            vec_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// A notification in the server.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiNotification {
    pub code: i32,
    pub content: String,
    pub create_time: String,
    pub id: String,
    pub persistent: bool,
    pub sender_id: String,
    pub subject: String,
}

impl ToRestString for ApiNotification {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"code\": {}", self.code.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"content\": \"{}\"", self.content));

        output.push_str(",");
        output.push_str(&format!("\"createTime\": \"{}\"", self.create_time));

        output.push_str(",");
        output.push_str(&format!("\"id\": \"{}\"", self.id));

        output.push_str(",");
        output.push_str(&format!("\"persistent\": {}", self.persistent.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"senderId\": \"{}\"", self.sender_id));

        output.push_str(",");
        output.push_str(&format!("\"subject\": \"{}\"", self.subject));
        output.push_str("}");
        return output;
    }
}

/// A collection of zero or more notifications.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiNotificationList {
    pub cacheable_cursor: String,
    pub notifications: Vec<ApiNotification>,
}

impl ToRestString for ApiNotificationList {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!(
            "\"cacheableCursor\": \"{}\"",
            self.cacheable_cursor
        ));

        output.push_str(",");
        output.push_str(&format!("\"notifications\": [{}]", {
            let vec_string = self
                .notifications
                .iter()
                .map(|x| x.to_string())
                .collect::<Vec<_>>();
            vec_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// Operator that can be used to override the one set in the leaderboard.   - NO_OVERRIDE: Do not override the leaderboard operator.  - BEST: Override the leaderboard operator with BEST.  - SET: Override the leaderboard operator with SET.  - INCREMENT: Override the leaderboard operator with INCREMENT.  - DECREMENT: Override the leaderboard operator with DECREMENT.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiOverrideOperator {}

impl ToRestString for ApiOverrideOperator {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");
        output.push_str("}");
        return output;
    }
}

/// Storage objects to get.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiReadStorageObjectId {
    pub collection: String,
    pub key: String,
    pub user_id: String,
}

impl ToRestString for ApiReadStorageObjectId {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"collection\": \"{}\"", self.collection));

        output.push_str(",");
        output.push_str(&format!("\"key\": \"{}\"", self.key));

        output.push_str(",");
        output.push_str(&format!("\"userId\": \"{}\"", self.user_id));
        output.push_str("}");
        return output;
    }
}

/// Batch get storage objects.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiReadStorageObjectsRequest {
    pub object_ids: Vec<ApiReadStorageObjectId>,
}

impl ToRestString for ApiReadStorageObjectsRequest {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"objectIds\": [{}]", {
            let vec_string = self
                .object_ids
                .iter()
                .map(|x| x.to_string())
                .collect::<Vec<_>>();
            vec_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// Execute an Lua function on the server.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiRpc {
    pub http_key: String,
    pub id: String,
    pub payload: String,
}

impl ToRestString for ApiRpc {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"httpKey\": \"{}\"", self.http_key));

        output.push_str(",");
        output.push_str(&format!("\"id\": \"{}\"", self.id));

        output.push_str(",");
        output.push_str(&format!("\"payload\": \"{}\"", self.payload));
        output.push_str("}");
        return output;
    }
}

/// A user's session used to authenticate messages.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiSession {
    pub created: bool,
    pub refresh_token: String,
    pub token: String,
}

impl ToRestString for ApiSession {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"created\": {}", self.created.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"refreshToken\": \"{}\"", self.refresh_token));

        output.push_str(",");
        output.push_str(&format!("\"token\": \"{}\"", self.token));
        output.push_str("}");
        return output;
    }
}

/// Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiSessionLogoutRequest {
    pub refresh_token: String,
    pub token: String,
}

impl ToRestString for ApiSessionLogoutRequest {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"refreshToken\": \"{}\"", self.refresh_token));

        output.push_str(",");
        output.push_str(&format!("\"token\": \"{}\"", self.token));
        output.push_str("}");
        return output;
    }
}

/// Authenticate against the server with a refresh token.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiSessionRefreshRequest {
    pub token: String,
    pub vars: HashMap<String, String>,
}

impl ToRestString for ApiSessionRefreshRequest {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"token\": \"{}\"", self.token));

        output.push_str(",");
        output.push_str(&format!("\"vars\": {{ {} }}", {
            let map_string = self
                .vars
                .iter()
                .map(|(key, value)| format!("\"{}\": \"{}\"", key.to_string(), value.to_string()))
                .collect::<Vec<_>>();
            map_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// An object within the storage engine.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiStorageObject {
    pub collection: String,
    pub create_time: String,
    pub key: String,
    pub permission_read: i32,
    pub permission_write: i32,
    pub update_time: String,
    pub user_id: String,
    pub value: String,
    pub version: String,
}

impl ToRestString for ApiStorageObject {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"collection\": \"{}\"", self.collection));

        output.push_str(",");
        output.push_str(&format!("\"createTime\": \"{}\"", self.create_time));

        output.push_str(",");
        output.push_str(&format!("\"key\": \"{}\"", self.key));

        output.push_str(",");
        output.push_str(&format!(
            "\"permissionRead\": {}",
            self.permission_read.to_string()
        ));

        output.push_str(",");
        output.push_str(&format!(
            "\"permissionWrite\": {}",
            self.permission_write.to_string()
        ));

        output.push_str(",");
        output.push_str(&format!("\"updateTime\": \"{}\"", self.update_time));

        output.push_str(",");
        output.push_str(&format!("\"userId\": \"{}\"", self.user_id));

        output.push_str(",");
        output.push_str(&format!("\"value\": \"{}\"", self.value));

        output.push_str(",");
        output.push_str(&format!("\"version\": \"{}\"", self.version));
        output.push_str("}");
        return output;
    }
}

/// A storage acknowledgement.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiStorageObjectAck {
    pub collection: String,
    pub key: String,
    pub user_id: String,
    pub version: String,
}

impl ToRestString for ApiStorageObjectAck {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"collection\": \"{}\"", self.collection));

        output.push_str(",");
        output.push_str(&format!("\"key\": \"{}\"", self.key));

        output.push_str(",");
        output.push_str(&format!("\"userId\": \"{}\"", self.user_id));

        output.push_str(",");
        output.push_str(&format!("\"version\": \"{}\"", self.version));
        output.push_str("}");
        return output;
    }
}

/// Batch of acknowledgements for the storage object write.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiStorageObjectAcks {
    pub acks: Vec<ApiStorageObjectAck>,
}

impl ToRestString for ApiStorageObjectAcks {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"acks\": [{}]", {
            let vec_string = self.acks.iter().map(|x| x.to_string()).collect::<Vec<_>>();
            vec_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// List of storage objects.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiStorageObjectList {
    pub cursor: String,
    pub objects: Vec<ApiStorageObject>,
}

impl ToRestString for ApiStorageObjectList {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"cursor\": \"{}\"", self.cursor));

        output.push_str(",");
        output.push_str(&format!("\"objects\": [{}]", {
            let vec_string = self
                .objects
                .iter()
                .map(|x| x.to_string())
                .collect::<Vec<_>>();
            vec_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// Batch of storage objects.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiStorageObjects {
    pub objects: Vec<ApiStorageObject>,
}

impl ToRestString for ApiStorageObjects {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"objects\": [{}]", {
            let vec_string = self
                .objects
                .iter()
                .map(|x| x.to_string())
                .collect::<Vec<_>>();
            vec_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// A tournament on the server.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiTournament {
    pub can_enter: bool,
    pub category: i32,
    pub create_time: String,
    pub description: String,
    pub duration: i32,
    pub end_active: i32,
    pub end_time: String,
    pub id: String,
    pub max_num_score: i32,
    pub max_size: i32,
    pub metadata: String,
    pub next_reset: i32,
    pub size: i32,
    pub sort_order: i32,
    pub start_active: i32,
    pub start_time: String,
    pub title: String,
}

impl ToRestString for ApiTournament {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"canEnter\": {}", self.can_enter.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"category\": {}", self.category.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"createTime\": \"{}\"", self.create_time));

        output.push_str(",");
        output.push_str(&format!("\"description\": \"{}\"", self.description));

        output.push_str(",");
        output.push_str(&format!("\"duration\": {}", self.duration.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"endActive\": {}", self.end_active.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"endTime\": \"{}\"", self.end_time));

        output.push_str(",");
        output.push_str(&format!("\"id\": \"{}\"", self.id));

        output.push_str(",");
        output.push_str(&format!(
            "\"maxNumScore\": {}",
            self.max_num_score.to_string()
        ));

        output.push_str(",");
        output.push_str(&format!("\"maxSize\": {}", self.max_size.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"metadata\": \"{}\"", self.metadata));

        output.push_str(",");
        output.push_str(&format!("\"nextReset\": {}", self.next_reset.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"size\": {}", self.size.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"sortOrder\": {}", self.sort_order.to_string()));

        output.push_str(",");
        output.push_str(&format!(
            "\"startActive\": {}",
            self.start_active.to_string()
        ));

        output.push_str(",");
        output.push_str(&format!("\"startTime\": \"{}\"", self.start_time));

        output.push_str(",");
        output.push_str(&format!("\"title\": \"{}\"", self.title));
        output.push_str("}");
        return output;
    }
}

/// A list of tournaments.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiTournamentList {
    pub cursor: String,
    pub tournaments: Vec<ApiTournament>,
}

impl ToRestString for ApiTournamentList {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"cursor\": \"{}\"", self.cursor));

        output.push_str(",");
        output.push_str(&format!("\"tournaments\": [{}]", {
            let vec_string = self
                .tournaments
                .iter()
                .map(|x| x.to_string())
                .collect::<Vec<_>>();
            vec_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// A set of tournament records which may be part of a tournament records page or a batch of individual records.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiTournamentRecordList {
    pub next_cursor: String,
    pub owner_records: Vec<ApiLeaderboardRecord>,
    pub prev_cursor: String,
    pub records: Vec<ApiLeaderboardRecord>,
}

impl ToRestString for ApiTournamentRecordList {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"nextCursor\": \"{}\"", self.next_cursor));

        output.push_str(",");
        output.push_str(&format!("\"ownerRecords\": [{}]", {
            let vec_string = self
                .owner_records
                .iter()
                .map(|x| x.to_string())
                .collect::<Vec<_>>();
            vec_string.join(", ")
        }));

        output.push_str(",");
        output.push_str(&format!("\"prevCursor\": \"{}\"", self.prev_cursor));

        output.push_str(",");
        output.push_str(&format!("\"records\": [{}]", {
            let vec_string = self
                .records
                .iter()
                .map(|x| x.to_string())
                .collect::<Vec<_>>();
            vec_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// Update a user's account details.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiUpdateAccountRequest {
    pub avatar_url: String,
    pub display_name: String,
    pub lang_tag: String,
    pub location: String,
    pub timezone: String,
    pub username: String,
}

impl ToRestString for ApiUpdateAccountRequest {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"avatarUrl\": \"{}\"", self.avatar_url));

        output.push_str(",");
        output.push_str(&format!("\"displayName\": \"{}\"", self.display_name));

        output.push_str(",");
        output.push_str(&format!("\"langTag\": \"{}\"", self.lang_tag));

        output.push_str(",");
        output.push_str(&format!("\"location\": \"{}\"", self.location));

        output.push_str(",");
        output.push_str(&format!("\"timezone\": \"{}\"", self.timezone));

        output.push_str(",");
        output.push_str(&format!("\"username\": \"{}\"", self.username));
        output.push_str("}");
        return output;
    }
}

/// Update fields in a given group.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiUpdateGroupRequest {
    pub avatar_url: String,
    pub description: String,
    pub group_id: String,
    pub lang_tag: String,
    pub name: String,
    pub open: bool,
}

impl ToRestString for ApiUpdateGroupRequest {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"avatarUrl\": \"{}\"", self.avatar_url));

        output.push_str(",");
        output.push_str(&format!("\"description\": \"{}\"", self.description));

        output.push_str(",");
        output.push_str(&format!("\"groupId\": \"{}\"", self.group_id));

        output.push_str(",");
        output.push_str(&format!("\"langTag\": \"{}\"", self.lang_tag));

        output.push_str(",");
        output.push_str(&format!("\"name\": \"{}\"", self.name));

        output.push_str(",");
        output.push_str(&format!("\"open\": {}", self.open.to_string()));
        output.push_str("}");
        return output;
    }
}

/// A user in the server.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiUser {
    pub apple_id: String,
    pub avatar_url: String,
    pub create_time: String,
    pub display_name: String,
    pub edge_count: i32,
    pub facebook_id: String,
    pub facebook_instant_game_id: String,
    pub gamecenter_id: String,
    pub google_id: String,
    pub id: String,
    pub lang_tag: String,
    pub location: String,
    pub metadata: String,
    pub online: bool,
    pub steam_id: String,
    pub timezone: String,
    pub update_time: String,
    pub username: String,
}

impl ToRestString for ApiUser {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"appleId\": \"{}\"", self.apple_id));

        output.push_str(",");
        output.push_str(&format!("\"avatarUrl\": \"{}\"", self.avatar_url));

        output.push_str(",");
        output.push_str(&format!("\"createTime\": \"{}\"", self.create_time));

        output.push_str(",");
        output.push_str(&format!("\"displayName\": \"{}\"", self.display_name));

        output.push_str(",");
        output.push_str(&format!("\"edgeCount\": {}", self.edge_count.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"facebookId\": \"{}\"", self.facebook_id));

        output.push_str(",");
        output.push_str(&format!(
            "\"facebookInstantGameId\": \"{}\"",
            self.facebook_instant_game_id
        ));

        output.push_str(",");
        output.push_str(&format!("\"gamecenterId\": \"{}\"", self.gamecenter_id));

        output.push_str(",");
        output.push_str(&format!("\"googleId\": \"{}\"", self.google_id));

        output.push_str(",");
        output.push_str(&format!("\"id\": \"{}\"", self.id));

        output.push_str(",");
        output.push_str(&format!("\"langTag\": \"{}\"", self.lang_tag));

        output.push_str(",");
        output.push_str(&format!("\"location\": \"{}\"", self.location));

        output.push_str(",");
        output.push_str(&format!("\"metadata\": \"{}\"", self.metadata));

        output.push_str(",");
        output.push_str(&format!("\"online\": {}", self.online.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"steamId\": \"{}\"", self.steam_id));

        output.push_str(",");
        output.push_str(&format!("\"timezone\": \"{}\"", self.timezone));

        output.push_str(",");
        output.push_str(&format!("\"updateTime\": \"{}\"", self.update_time));

        output.push_str(",");
        output.push_str(&format!("\"username\": \"{}\"", self.username));
        output.push_str("}");
        return output;
    }
}

/// A list of groups belonging to a user, along with the user's role in each group.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiUserGroupList {
    pub cursor: String,
    pub user_groups: Vec<UserGroupListUserGroup>,
}

impl ToRestString for ApiUserGroupList {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"cursor\": \"{}\"", self.cursor));

        output.push_str(",");
        output.push_str(&format!("\"userGroups\": [{}]", {
            let vec_string = self
                .user_groups
                .iter()
                .map(|x| x.to_string())
                .collect::<Vec<_>>();
            vec_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// A collection of zero or more users.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiUsers {
    pub users: Vec<ApiUser>,
}

impl ToRestString for ApiUsers {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"users\": [{}]", {
            let vec_string = self.users.iter().map(|x| x.to_string()).collect::<Vec<_>>();
            vec_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

///
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiValidatePurchaseAppleRequest {
    pub receipt: String,
}

impl ToRestString for ApiValidatePurchaseAppleRequest {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"receipt\": \"{}\"", self.receipt));
        output.push_str("}");
        return output;
    }
}

///
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiValidatePurchaseGoogleRequest {
    pub purchase: String,
}

impl ToRestString for ApiValidatePurchaseGoogleRequest {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"purchase\": \"{}\"", self.purchase));
        output.push_str("}");
        return output;
    }
}

///
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiValidatePurchaseHuaweiRequest {
    pub purchase: String,
    pub signature: String,
}

impl ToRestString for ApiValidatePurchaseHuaweiRequest {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"purchase\": \"{}\"", self.purchase));

        output.push_str(",");
        output.push_str(&format!("\"signature\": \"{}\"", self.signature));
        output.push_str("}");
        return output;
    }
}

///
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiValidatePurchaseResponse {
    pub validated_purchases: Vec<ApiValidatedPurchase>,
}

impl ToRestString for ApiValidatePurchaseResponse {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"validatedPurchases\": [{}]", {
            let vec_string = self
                .validated_purchases
                .iter()
                .map(|x| x.to_string())
                .collect::<Vec<_>>();
            vec_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

/// Validated Purchase stored by Nakama.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiValidatedPurchase {
    pub create_time: String,
    pub environment: ValidatedPurchaseEnvironment,
    pub product_id: String,
    pub provider_response: String,
    pub purchase_time: String,
    pub store: ValidatedPurchaseStore,
    pub transaction_id: String,
    pub update_time: String,
}

impl ToRestString for ApiValidatedPurchase {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"createTime\": \"{}\"", self.create_time));

        output.push_str(",");
        output.push_str(&format!(
            "\"environment\": {}",
            self.environment.to_string()
        ));

        output.push_str(",");
        output.push_str(&format!("\"productId\": \"{}\"", self.product_id));

        output.push_str(",");
        output.push_str(&format!(
            "\"providerResponse\": \"{}\"",
            self.provider_response
        ));

        output.push_str(",");
        output.push_str(&format!("\"purchaseTime\": \"{}\"", self.purchase_time));

        output.push_str(",");
        output.push_str(&format!("\"store\": {}", self.store.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"transactionId\": \"{}\"", self.transaction_id));

        output.push_str(",");
        output.push_str(&format!("\"updateTime\": \"{}\"", self.update_time));
        output.push_str("}");
        return output;
    }
}

/// The object to store.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiWriteStorageObject {
    pub collection: String,
    pub key: String,
    pub permission_read: i32,
    pub permission_write: i32,
    pub value: String,
    pub version: String,
}

impl ToRestString for ApiWriteStorageObject {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"collection\": \"{}\"", self.collection));

        output.push_str(",");
        output.push_str(&format!("\"key\": \"{}\"", self.key));

        output.push_str(",");
        output.push_str(&format!(
            "\"permissionRead\": {}",
            self.permission_read.to_string()
        ));

        output.push_str(",");
        output.push_str(&format!(
            "\"permissionWrite\": {}",
            self.permission_write.to_string()
        ));

        output.push_str(",");
        output.push_str(&format!("\"value\": \"{}\"", self.value));

        output.push_str(",");
        output.push_str(&format!("\"version\": \"{}\"", self.version));
        output.push_str("}");
        return output;
    }
}

/// Write objects to the storage engine.
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ApiWriteStorageObjectsRequest {
    pub objects: Vec<ApiWriteStorageObject>,
}

impl ToRestString for ApiWriteStorageObjectsRequest {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"objects\": [{}]", {
            let vec_string = self
                .objects
                .iter()
                .map(|x| x.to_string())
                .collect::<Vec<_>>();
            vec_string.join(", ")
        }));
        output.push_str("}");
        return output;
    }
}

///
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct ProtobufAny {
    pub type_url: String,
    pub value: String,
}

impl ToRestString for ProtobufAny {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"typeUrl\": \"{}\"", self.type_url));

        output.push_str(",");
        output.push_str(&format!("\"value\": \"{}\"", self.value));
        output.push_str("}");
        return output;
    }
}

///
#[derive(Debug, DeJson, Default, Clone)]
#[nserde(default)]
pub struct RpcStatus {
    pub code: i32,
    pub details: Vec<ProtobufAny>,
    pub message: String,
}

impl ToRestString for RpcStatus {
    fn to_string(&self) -> String {
        let mut output = String::new();

        output.push_str("{");

        output.push_str(&format!("\"code\": {}", self.code.to_string()));

        output.push_str(",");
        output.push_str(&format!("\"details\": [{}]", {
            let vec_string = self
                .details
                .iter()
                .map(|x| x.to_string())
                .collect::<Vec<_>>();
            vec_string.join(", ")
        }));

        output.push_str(",");
        output.push_str(&format!("\"message\": \"{}\"", self.message));
        output.push_str("}");
        return output;
    }
}
/// A healthcheck which load balancers can use to check the service.
pub fn healthcheck(bearer_token: &str) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/healthcheck".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Fetch the current user's account.
pub fn get_account(bearer_token: &str) -> RestRequest<ApiAccount> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Update fields in the current user's account.
pub fn update_account(bearer_token: &str, body: ApiUpdateAccountRequest) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Put;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Authenticate a user with an Apple ID against the server.
pub fn authenticate_apple(
    basic_auth_username: &str,
    basic_auth_password: &str,
    body: ApiAccountApple,
    create: Option<bool>,
    username: Option<&str>,
) -> RestRequest<ApiSession> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/authenticate/apple".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = create {
        query_params.push_str(&format!("create={:?}&", param));
    }
    if let Some(param) = username {
        query_params.push_str(&format!("username={}&", param));
    }

    let authentication = Authentication::Basic {
        username: basic_auth_username.to_owned(),
        password: basic_auth_password.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Authenticate a user with a custom id against the server.
pub fn authenticate_custom(
    basic_auth_username: &str,
    basic_auth_password: &str,
    body: ApiAccountCustom,
    create: Option<bool>,
    username: Option<&str>,
) -> RestRequest<ApiSession> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/authenticate/custom".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = create {
        query_params.push_str(&format!("create={:?}&", param));
    }
    if let Some(param) = username {
        query_params.push_str(&format!("username={}&", param));
    }

    let authentication = Authentication::Basic {
        username: basic_auth_username.to_owned(),
        password: basic_auth_password.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Authenticate a user with a device id against the server.
pub fn authenticate_device(
    basic_auth_username: &str,
    basic_auth_password: &str,
    body: ApiAccountDevice,
    create: Option<bool>,
    username: Option<&str>,
) -> RestRequest<ApiSession> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/authenticate/device".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = create {
        query_params.push_str(&format!("create={:?}&", param));
    }
    if let Some(param) = username {
        query_params.push_str(&format!("username={}&", param));
    }

    let authentication = Authentication::Basic {
        username: basic_auth_username.to_owned(),
        password: basic_auth_password.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Authenticate a user with an email+password against the server.
pub fn authenticate_email(
    basic_auth_username: &str,
    basic_auth_password: &str,
    body: ApiAccountEmail,
    create: Option<bool>,
    username: Option<&str>,
) -> RestRequest<ApiSession> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/authenticate/email".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = create {
        query_params.push_str(&format!("create={:?}&", param));
    }
    if let Some(param) = username {
        query_params.push_str(&format!("username={}&", param));
    }

    let authentication = Authentication::Basic {
        username: basic_auth_username.to_owned(),
        password: basic_auth_password.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Authenticate a user with a Facebook OAuth token against the server.
pub fn authenticate_facebook(
    basic_auth_username: &str,
    basic_auth_password: &str,
    body: ApiAccountFacebook,
    create: Option<bool>,
    username: Option<&str>,
    sync: Option<bool>,
) -> RestRequest<ApiSession> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/authenticate/facebook".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = create {
        query_params.push_str(&format!("create={:?}&", param));
    }
    if let Some(param) = username {
        query_params.push_str(&format!("username={}&", param));
    }
    if let Some(param) = sync {
        query_params.push_str(&format!("sync={:?}&", param));
    }

    let authentication = Authentication::Basic {
        username: basic_auth_username.to_owned(),
        password: basic_auth_password.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Authenticate a user with a Facebook Instant Game token against the server.
pub fn authenticate_facebook_instant_game(
    basic_auth_username: &str,
    basic_auth_password: &str,
    body: ApiAccountFacebookInstantGame,
    create: Option<bool>,
    username: Option<&str>,
) -> RestRequest<ApiSession> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/authenticate/facebookinstantgame".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = create {
        query_params.push_str(&format!("create={:?}&", param));
    }
    if let Some(param) = username {
        query_params.push_str(&format!("username={}&", param));
    }

    let authentication = Authentication::Basic {
        username: basic_auth_username.to_owned(),
        password: basic_auth_password.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Authenticate a user with Apple's GameCenter against the server.
pub fn authenticate_game_center(
    basic_auth_username: &str,
    basic_auth_password: &str,
    body: ApiAccountGameCenter,
    create: Option<bool>,
    username: Option<&str>,
) -> RestRequest<ApiSession> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/authenticate/gamecenter".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = create {
        query_params.push_str(&format!("create={:?}&", param));
    }
    if let Some(param) = username {
        query_params.push_str(&format!("username={}&", param));
    }

    let authentication = Authentication::Basic {
        username: basic_auth_username.to_owned(),
        password: basic_auth_password.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Authenticate a user with Google against the server.
pub fn authenticate_google(
    basic_auth_username: &str,
    basic_auth_password: &str,
    body: ApiAccountGoogle,
    create: Option<bool>,
    username: Option<&str>,
) -> RestRequest<ApiSession> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/authenticate/google".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = create {
        query_params.push_str(&format!("create={:?}&", param));
    }
    if let Some(param) = username {
        query_params.push_str(&format!("username={}&", param));
    }

    let authentication = Authentication::Basic {
        username: basic_auth_username.to_owned(),
        password: basic_auth_password.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Authenticate a user with Steam against the server.
pub fn authenticate_steam(
    basic_auth_username: &str,
    basic_auth_password: &str,
    body: ApiAccountSteam,
    create: Option<bool>,
    username: Option<&str>,
    sync: Option<bool>,
) -> RestRequest<ApiSession> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/authenticate/steam".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = create {
        query_params.push_str(&format!("create={:?}&", param));
    }
    if let Some(param) = username {
        query_params.push_str(&format!("username={}&", param));
    }
    if let Some(param) = sync {
        query_params.push_str(&format!("sync={:?}&", param));
    }

    let authentication = Authentication::Basic {
        username: basic_auth_username.to_owned(),
        password: basic_auth_password.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Add an Apple ID to the social profiles on the current user's account.
pub fn link_apple(bearer_token: &str, body: ApiAccountApple) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/link/apple".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Add a custom ID to the social profiles on the current user's account.
pub fn link_custom(bearer_token: &str, body: ApiAccountCustom) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/link/custom".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Add a device ID to the social profiles on the current user's account.
pub fn link_device(bearer_token: &str, body: ApiAccountDevice) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/link/device".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Add an email+password to the social profiles on the current user's account.
pub fn link_email(bearer_token: &str, body: ApiAccountEmail) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/link/email".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Add Facebook to the social profiles on the current user's account.
pub fn link_facebook(
    bearer_token: &str,
    body: ApiAccountFacebook,
    sync: Option<bool>,
) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/link/facebook".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = sync {
        query_params.push_str(&format!("sync={:?}&", param));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Add Facebook Instant Game to the social profiles on the current user's account.
pub fn link_facebook_instant_game(
    bearer_token: &str,
    body: ApiAccountFacebookInstantGame,
) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/link/facebookinstantgame".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Add Apple's GameCenter to the social profiles on the current user's account.
pub fn link_game_center(bearer_token: &str, body: ApiAccountGameCenter) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/link/gamecenter".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Add Google to the social profiles on the current user's account.
pub fn link_google(bearer_token: &str, body: ApiAccountGoogle) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/link/google".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Add Steam to the social profiles on the current user's account.
pub fn link_steam(bearer_token: &str, body: ApiLinkSteamRequest) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/link/steam".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Refresh a user's session using a refresh token retrieved from a previous authentication request.
pub fn session_refresh(
    basic_auth_username: &str,
    basic_auth_password: &str,
    body: ApiSessionRefreshRequest,
) -> RestRequest<ApiSession> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/session/refresh".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Basic {
        username: basic_auth_username.to_owned(),
        password: basic_auth_password.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Remove the Apple ID from the social profiles on the current user's account.
pub fn unlink_apple(bearer_token: &str, body: ApiAccountApple) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/unlink/apple".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Remove the custom ID from the social profiles on the current user's account.
pub fn unlink_custom(bearer_token: &str, body: ApiAccountCustom) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/unlink/custom".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Remove the device ID from the social profiles on the current user's account.
pub fn unlink_device(bearer_token: &str, body: ApiAccountDevice) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/unlink/device".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Remove the email+password from the social profiles on the current user's account.
pub fn unlink_email(bearer_token: &str, body: ApiAccountEmail) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/unlink/email".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Remove Facebook from the social profiles on the current user's account.
pub fn unlink_facebook(bearer_token: &str, body: ApiAccountFacebook) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/unlink/facebook".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Remove Facebook Instant Game profile from the social profiles on the current user's account.
pub fn unlink_facebook_instant_game(
    bearer_token: &str,
    body: ApiAccountFacebookInstantGame,
) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/unlink/facebookinstantgame".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Remove Apple's GameCenter from the social profiles on the current user's account.
pub fn unlink_game_center(bearer_token: &str, body: ApiAccountGameCenter) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/unlink/gamecenter".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Remove Google from the social profiles on the current user's account.
pub fn unlink_google(bearer_token: &str, body: ApiAccountGoogle) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/unlink/google".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Remove Steam from the social profiles on the current user's account.
pub fn unlink_steam(bearer_token: &str, body: ApiAccountSteam) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/unlink/steam".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// List a channel's message history.
pub fn list_channel_messages(
    bearer_token: &str,
    channel_id: &str,
    limit: Option<i32>,
    forward: Option<bool>,
    cursor: Option<&str>,
) -> RestRequest<ApiChannelMessageList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/channel/{channelId}".to_string();
    urlpath = urlpath.replace("{channelId}", channel_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = forward {
        query_params.push_str(&format!("forward={:?}&", param));
    }
    if let Some(param) = cursor {
        query_params.push_str(&format!("cursor={}&", param));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Submit an event for processing in the server's registered runtime custom events handler.
pub fn event(bearer_token: &str, body: ApiEvent) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/event".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Delete one or more users by ID or username.
pub fn delete_friends(bearer_token: &str, ids: &[String], usernames: &[String]) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/friend".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    for elem in ids {
        query_params.push_str(&format!("ids={:?}&", elem));
    }
    for elem in usernames {
        query_params.push_str(&format!("usernames={:?}&", elem));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Delete;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// List all friends for the current user.
pub fn list_friends(
    bearer_token: &str,
    limit: Option<i32>,
    state: Option<i32>,
    cursor: Option<&str>,
) -> RestRequest<ApiFriendList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/friend".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = state {
        query_params.push_str(&format!("state={}&", param));
    }
    if let Some(param) = cursor {
        query_params.push_str(&format!("cursor={}&", param));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Add friends by ID or username to a user's account.
pub fn add_friends(bearer_token: &str, ids: &[String], usernames: &[String]) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/friend".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    for elem in ids {
        query_params.push_str(&format!("ids={:?}&", elem));
    }
    for elem in usernames {
        query_params.push_str(&format!("usernames={:?}&", elem));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Block one or more users by ID or username.
pub fn block_friends(bearer_token: &str, ids: &[String], usernames: &[String]) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/friend/block".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    for elem in ids {
        query_params.push_str(&format!("ids={:?}&", elem));
    }
    for elem in usernames {
        query_params.push_str(&format!("usernames={:?}&", elem));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Import Facebook friends and add them to a user's account.
pub fn import_facebook_friends(
    bearer_token: &str,
    body: ApiAccountFacebook,
    reset: Option<bool>,
) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/friend/facebook".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = reset {
        query_params.push_str(&format!("reset={:?}&", param));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Import Steam friends and add them to a user's account.
pub fn import_steam_friends(
    bearer_token: &str,
    body: ApiAccountSteam,
    reset: Option<bool>,
) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/friend/steam".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = reset {
        query_params.push_str(&format!("reset={:?}&", param));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// List groups based on given filters.
pub fn list_groups(
    bearer_token: &str,
    name: Option<&str>,
    cursor: Option<&str>,
    limit: Option<i32>,
) -> RestRequest<ApiGroupList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/group".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = name {
        query_params.push_str(&format!("name={}&", param));
    }
    if let Some(param) = cursor {
        query_params.push_str(&format!("cursor={}&", param));
    }
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Create a new group with the current user as the owner.
pub fn create_group(bearer_token: &str, body: ApiCreateGroupRequest) -> RestRequest<ApiGroup> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/group".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Delete a group by ID.
pub fn delete_group(bearer_token: &str, group_id: &str) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/group/{groupId}".to_string();
    urlpath = urlpath.replace("{groupId}", group_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Delete;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Update fields in a given group.
pub fn update_group(
    bearer_token: &str,
    group_id: &str,
    body: ApiUpdateGroupRequest,
) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/group/{groupId}".to_string();
    urlpath = urlpath.replace("{groupId}", group_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Put;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Add users to a group.
pub fn add_group_users(bearer_token: &str, group_id: &str, user_ids: &[String]) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/group/{groupId}/add".to_string();
    urlpath = urlpath.replace("{groupId}", group_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    for elem in user_ids {
        query_params.push_str(&format!("user_ids={:?}&", elem));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Ban a set of users from a group.
pub fn ban_group_users(bearer_token: &str, group_id: &str, user_ids: &[String]) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/group/{groupId}/ban".to_string();
    urlpath = urlpath.replace("{groupId}", group_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    for elem in user_ids {
        query_params.push_str(&format!("user_ids={:?}&", elem));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Demote a set of users in a group to the next role down.
pub fn demote_group_users(
    bearer_token: &str,
    group_id: &str,
    user_ids: &[String],
) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/group/{groupId}/demote".to_string();
    urlpath = urlpath.replace("{groupId}", group_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    for elem in user_ids {
        query_params.push_str(&format!("user_ids={:?}&", elem));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Immediately join an open group, or request to join a closed one.
pub fn join_group(bearer_token: &str, group_id: &str) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/group/{groupId}/join".to_string();
    urlpath = urlpath.replace("{groupId}", group_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Kick a set of users from a group.
pub fn kick_group_users(
    bearer_token: &str,
    group_id: &str,
    user_ids: &[String],
) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/group/{groupId}/kick".to_string();
    urlpath = urlpath.replace("{groupId}", group_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    for elem in user_ids {
        query_params.push_str(&format!("user_ids={:?}&", elem));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Leave a group the user is a member of.
pub fn leave_group(bearer_token: &str, group_id: &str) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/group/{groupId}/leave".to_string();
    urlpath = urlpath.replace("{groupId}", group_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Promote a set of users in a group to the next role up.
pub fn promote_group_users(
    bearer_token: &str,
    group_id: &str,
    user_ids: &[String],
) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/group/{groupId}/promote".to_string();
    urlpath = urlpath.replace("{groupId}", group_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    for elem in user_ids {
        query_params.push_str(&format!("user_ids={:?}&", elem));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// List all users that are part of a group.
pub fn list_group_users(
    bearer_token: &str,
    group_id: &str,
    limit: Option<i32>,
    state: Option<i32>,
    cursor: Option<&str>,
) -> RestRequest<ApiGroupUserList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/group/{groupId}/user".to_string();
    urlpath = urlpath.replace("{groupId}", group_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = state {
        query_params.push_str(&format!("state={}&", param));
    }
    if let Some(param) = cursor {
        query_params.push_str(&format!("cursor={}&", param));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Validate Apple IAP Receipt
pub fn validate_purchase_apple(
    bearer_token: &str,
    body: ApiValidatePurchaseAppleRequest,
) -> RestRequest<ApiValidatePurchaseResponse> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/iap/purchase/apple".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Validate Google IAP Receipt
pub fn validate_purchase_google(
    bearer_token: &str,
    body: ApiValidatePurchaseGoogleRequest,
) -> RestRequest<ApiValidatePurchaseResponse> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/iap/purchase/google".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Validate Huawei IAP Receipt
pub fn validate_purchase_huawei(
    bearer_token: &str,
    body: ApiValidatePurchaseHuaweiRequest,
) -> RestRequest<ApiValidatePurchaseResponse> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/iap/purchase/huawei".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Delete a leaderboard record.
pub fn delete_leaderboard_record(bearer_token: &str, leaderboard_id: &str) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/leaderboard/{leaderboardId}".to_string();
    urlpath = urlpath.replace("{leaderboardId}", leaderboard_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Delete;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// List leaderboard records.
pub fn list_leaderboard_records(
    bearer_token: &str,
    leaderboard_id: &str,
    owner_ids: &[String],
    limit: Option<i32>,
    cursor: Option<&str>,
    expiry: Option<&str>,
) -> RestRequest<ApiLeaderboardRecordList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/leaderboard/{leaderboardId}".to_string();
    urlpath = urlpath.replace("{leaderboardId}", leaderboard_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    for elem in owner_ids {
        query_params.push_str(&format!("owner_ids={:?}&", elem));
    }
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = cursor {
        query_params.push_str(&format!("cursor={}&", param));
    }
    if let Some(param) = expiry {
        query_params.push_str(&format!("expiry={}&", param));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Write a record to a leaderboard.
pub fn write_leaderboard_record(
    bearer_token: &str,
    leaderboard_id: &str,
    body: WriteLeaderboardRecordRequestLeaderboardRecordWrite,
) -> RestRequest<ApiLeaderboardRecord> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/leaderboard/{leaderboardId}".to_string();
    urlpath = urlpath.replace("{leaderboardId}", leaderboard_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// List leaderboard records that belong to a user.
pub fn list_leaderboard_records_around_owner(
    bearer_token: &str,
    leaderboard_id: &str,
    owner_id: &str,
    limit: Option<i32>,
    expiry: Option<&str>,
) -> RestRequest<ApiLeaderboardRecordList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/leaderboard/{leaderboardId}/owner/{ownerId}".to_string();
    urlpath = urlpath.replace("{leaderboardId}", leaderboard_id);
    urlpath = urlpath.replace("{ownerId}", owner_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = expiry {
        query_params.push_str(&format!("expiry={}&", param));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Fetch list of running matches.
pub fn list_matches(
    bearer_token: &str,
    limit: Option<i32>,
    authoritative: Option<bool>,
    label: Option<&str>,
    min_size: Option<i32>,
    max_size: Option<i32>,
    query: Option<&str>,
) -> RestRequest<ApiMatchList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/match".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = authoritative {
        query_params.push_str(&format!("authoritative={:?}&", param));
    }
    if let Some(param) = label {
        query_params.push_str(&format!("label={}&", param));
    }
    if let Some(param) = min_size {
        query_params.push_str(&format!("min_size={}&", param));
    }
    if let Some(param) = max_size {
        query_params.push_str(&format!("max_size={}&", param));
    }
    if let Some(param) = query {
        query_params.push_str(&format!("query={}&", param));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Delete one or more notifications for the current user.
pub fn delete_notifications(bearer_token: &str, ids: &[String]) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/notification".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    for elem in ids {
        query_params.push_str(&format!("ids={:?}&", elem));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Delete;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Fetch list of notifications.
pub fn list_notifications(
    bearer_token: &str,
    limit: Option<i32>,
    cacheable_cursor: Option<&str>,
) -> RestRequest<ApiNotificationList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/notification".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = cacheable_cursor {
        query_params.push_str(&format!("cacheable_cursor={}&", param));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Execute a Lua function on the server.
pub fn rpc_func_2(
    bearer_token: &str,
    id: &str,
    payload: Option<&str>,
    http_key: Option<&str>,
) -> RestRequest<ApiRpc> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/rpc/{id}".to_string();
    urlpath = urlpath.replace("{id}", id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = payload {
        query_params.push_str(&format!("payload={}&", param));
    }
    if let Some(param) = http_key {
        query_params.push_str(&format!("http_key={}&", param));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Execute a Lua function on the server.
pub fn rpc_func(
    bearer_token: &str,
    id: &str,
    body: &str,
    http_key: Option<&str>,
) -> RestRequest<ApiRpc> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/rpc/{id}".to_string();
    urlpath = urlpath.replace("{id}", id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = http_key {
        query_params.push_str(&format!("http_key={}&", param));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user.
pub fn session_logout(bearer_token: &str, body: ApiSessionLogoutRequest) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/session/logout".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Get storage objects.
pub fn read_storage_objects(
    bearer_token: &str,
    body: ApiReadStorageObjectsRequest,
) -> RestRequest<ApiStorageObjects> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/storage".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Write objects into the storage engine.
pub fn write_storage_objects(
    bearer_token: &str,
    body: ApiWriteStorageObjectsRequest,
) -> RestRequest<ApiStorageObjectAcks> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/storage".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Put;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Delete one or more objects by ID or username.
pub fn delete_storage_objects(
    bearer_token: &str,
    body: ApiDeleteStorageObjectsRequest,
) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/storage/delete".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Put;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// List publicly readable storage objects in a given collection.
pub fn list_storage_objects(
    bearer_token: &str,
    collection: &str,
    user_id: Option<&str>,
    limit: Option<i32>,
    cursor: Option<&str>,
) -> RestRequest<ApiStorageObjectList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/storage/{collection}".to_string();
    urlpath = urlpath.replace("{collection}", collection);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = user_id {
        query_params.push_str(&format!("user_id={}&", param));
    }
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = cursor {
        query_params.push_str(&format!("cursor={}&", param));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// List publicly readable storage objects in a given collection.
pub fn list_storage_objects_2(
    bearer_token: &str,
    collection: &str,
    user_id: &str,
    limit: Option<i32>,
    cursor: Option<&str>,
) -> RestRequest<ApiStorageObjectList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/storage/{collection}/{userId}".to_string();
    urlpath = urlpath.replace("{collection}", collection);
    urlpath = urlpath.replace("{userId}", user_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = cursor {
        query_params.push_str(&format!("cursor={}&", param));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// List current or upcoming tournaments.
pub fn list_tournaments(
    bearer_token: &str,
    category_start: Option<i32>,
    category_end: Option<i32>,
    start_time: Option<i32>,
    end_time: Option<i32>,
    limit: Option<i32>,
    cursor: Option<&str>,
) -> RestRequest<ApiTournamentList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/tournament".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = category_start {
        query_params.push_str(&format!("category_start={}&", param));
    }
    if let Some(param) = category_end {
        query_params.push_str(&format!("category_end={}&", param));
    }
    if let Some(param) = start_time {
        query_params.push_str(&format!("start_time={}&", param));
    }
    if let Some(param) = end_time {
        query_params.push_str(&format!("end_time={}&", param));
    }
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = cursor {
        query_params.push_str(&format!("cursor={}&", param));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// List tournament records.
pub fn list_tournament_records(
    bearer_token: &str,
    tournament_id: &str,
    owner_ids: &[String],
    limit: Option<i32>,
    cursor: Option<&str>,
    expiry: Option<&str>,
) -> RestRequest<ApiTournamentRecordList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/tournament/{tournamentId}".to_string();
    urlpath = urlpath.replace("{tournamentId}", tournament_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    for elem in owner_ids {
        query_params.push_str(&format!("owner_ids={:?}&", elem));
    }
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = cursor {
        query_params.push_str(&format!("cursor={}&", param));
    }
    if let Some(param) = expiry {
        query_params.push_str(&format!("expiry={}&", param));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Write a record to a tournament.
pub fn write_tournament_record_2(
    bearer_token: &str,
    tournament_id: &str,
    body: WriteTournamentRecordRequestTournamentRecordWrite,
) -> RestRequest<ApiLeaderboardRecord> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/tournament/{tournamentId}".to_string();
    urlpath = urlpath.replace("{tournamentId}", tournament_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Write a record to a tournament.
pub fn write_tournament_record(
    bearer_token: &str,
    tournament_id: &str,
    body: WriteTournamentRecordRequestTournamentRecordWrite,
) -> RestRequest<ApiLeaderboardRecord> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/tournament/{tournamentId}".to_string();
    urlpath = urlpath.replace("{tournamentId}", tournament_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Put;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Attempt to join an open and running tournament.
pub fn join_tournament(bearer_token: &str, tournament_id: &str) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/tournament/{tournamentId}/join".to_string();
    urlpath = urlpath.replace("{tournamentId}", tournament_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// List tournament records for a given owner.
pub fn list_tournament_records_around_owner(
    bearer_token: &str,
    tournament_id: &str,
    owner_id: &str,
    limit: Option<i32>,
    expiry: Option<&str>,
) -> RestRequest<ApiTournamentRecordList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/tournament/{tournamentId}/owner/{ownerId}".to_string();
    urlpath = urlpath.replace("{tournamentId}", tournament_id);
    urlpath = urlpath.replace("{ownerId}", owner_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = expiry {
        query_params.push_str(&format!("expiry={}&", param));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// Fetch zero or more users by ID and/or username.
pub fn get_users(
    bearer_token: &str,
    ids: &[String],
    usernames: &[String],
    facebook_ids: &[String],
) -> RestRequest<ApiUsers> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/user".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    for elem in ids {
        query_params.push_str(&format!("ids={:?}&", elem));
    }
    for elem in usernames {
        query_params.push_str(&format!("usernames={:?}&", elem));
    }
    for elem in facebook_ids {
        query_params.push_str(&format!("facebook_ids={:?}&", elem));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
/// List groups the current user belongs to.
pub fn list_user_groups(
    bearer_token: &str,
    user_id: &str,
    limit: Option<i32>,
    state: Option<i32>,
    cursor: Option<&str>,
) -> RestRequest<ApiUserGroupList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/user/{userId}/group".to_string();
    urlpath = urlpath.replace("{userId}", user_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = state {
        query_params.push_str(&format!("state={}&", param));
    }
    if let Some(param) = cursor {
        query_params.push_str(&format!("cursor={}&", param));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
